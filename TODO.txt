Steps:
------

- Parse string template into a queue of blocks/segments (blocks can also has nested blocks/segments)
	- Each block represents raw content, an if statement, for loop etc
	- Validate each block as it is parsed
- Compile parsed template into executable template (which includes any dependencies such as functions that it needs)
	- Also validate variables references and function calls (function exits and valid parameters passed)
- When the compiled template is run, the model that is passed is auto inspected and all property values are put into a template model
	- The template model has a collection of initialised variables that can be added to at "runtime" and only used after they have been defined


Notes:
------

Parsed templates should contain an ordered collection of blocks, including pure content. The compiler/executer will run through each block in order, resolve it and then append like a string builder.

Blocks with nesting and content would do the same and recursively return the result until the entire block chain has resolved and single string is returned.



Each 'content block' (i.e. content contained within an if or for each etc) will have it's own model based on what is passed in?

Use RegEx to parse things like {{if X}}Y{{endif}} etc so we don't need so much validation and can easily handle no line breaks.
	- Won't work with nested loops etc!

When compiling template, create a sort if tree structure that contains all the resolvable things and nested content blocks.

Variables can only be used after declared/assigned so only resolve as we get to them - but validate during compilation.

Validation - check for invalid references to properties or variables that don't exist.

Store start and end coordinates for all blocks of code and content so they can easily be found and replaced. N.b. once one is the replace, the coordinates of anything after it will change so need to update everything after.

Need some sort of context/pipeline/stack while parsing to keep track of what is happening
